<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>System Programming | KEITH KWON</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" sizes="32x32" href="/images/favicon-32x32.png">
    <meta name="description" content="Developer based in Seoul">
    <meta name="google-site-verification" content="JyTpsE7AxKVeJeQR3P0s7_RDjE5zH6VGnIbWhSamXOQ">
    <meta property="og:image" content="https://github.com/keithkwon/keithkwon.github.io/blob/master/images/ogk.png?raw=true">
    <meta property="og:description" content="Developer based in Seoul">
    
    <link rel="preload" href="/assets/css/0.styles.9139df2e.css" as="style"><link rel="preload" href="/assets/js/app.8582b750.js" as="script"><link rel="preload" href="/assets/js/13.ac00c42d.js" as="script"><link rel="preload" href="/assets/js/1.31b6dd3f.js" as="script"><link rel="preload" href="/assets/js/47.bec85125.js" as="script"><link rel="prefetch" href="/assets/js/10.d8403849.js"><link rel="prefetch" href="/assets/js/11.12206cd1.js"><link rel="prefetch" href="/assets/js/12.708d8669.js"><link rel="prefetch" href="/assets/js/14.80aa024d.js"><link rel="prefetch" href="/assets/js/15.41ee70d5.js"><link rel="prefetch" href="/assets/js/16.ca59537c.js"><link rel="prefetch" href="/assets/js/17.81fd8108.js"><link rel="prefetch" href="/assets/js/18.764ba8e6.js"><link rel="prefetch" href="/assets/js/19.dd56091f.js"><link rel="prefetch" href="/assets/js/2.c520ccf8.js"><link rel="prefetch" href="/assets/js/20.2b3f1d94.js"><link rel="prefetch" href="/assets/js/21.99b92d64.js"><link rel="prefetch" href="/assets/js/22.17f29201.js"><link rel="prefetch" href="/assets/js/23.516e624a.js"><link rel="prefetch" href="/assets/js/24.732904d4.js"><link rel="prefetch" href="/assets/js/25.07942a3c.js"><link rel="prefetch" href="/assets/js/26.c3e1c6f5.js"><link rel="prefetch" href="/assets/js/27.bd3b9f2f.js"><link rel="prefetch" href="/assets/js/28.a02b18b5.js"><link rel="prefetch" href="/assets/js/29.5fc69af7.js"><link rel="prefetch" href="/assets/js/3.1ca3d9f1.js"><link rel="prefetch" href="/assets/js/30.5e7416df.js"><link rel="prefetch" href="/assets/js/31.a03c85d8.js"><link rel="prefetch" href="/assets/js/32.ee817a71.js"><link rel="prefetch" href="/assets/js/33.e87d6eb0.js"><link rel="prefetch" href="/assets/js/34.52e6779a.js"><link rel="prefetch" href="/assets/js/35.33774b57.js"><link rel="prefetch" href="/assets/js/36.f5de3fd7.js"><link rel="prefetch" href="/assets/js/37.f1faf98f.js"><link rel="prefetch" href="/assets/js/38.df88c064.js"><link rel="prefetch" href="/assets/js/39.e192feaa.js"><link rel="prefetch" href="/assets/js/40.6914ed18.js"><link rel="prefetch" href="/assets/js/41.cb7b542e.js"><link rel="prefetch" href="/assets/js/42.8d61c742.js"><link rel="prefetch" href="/assets/js/43.5bc513eb.js"><link rel="prefetch" href="/assets/js/44.6e4af15f.js"><link rel="prefetch" href="/assets/js/45.484a959d.js"><link rel="prefetch" href="/assets/js/46.752dc1ba.js"><link rel="prefetch" href="/assets/js/48.4e4c0ecf.js"><link rel="prefetch" href="/assets/js/49.fc5467d3.js"><link rel="prefetch" href="/assets/js/50.be453575.js"><link rel="prefetch" href="/assets/js/51.966057d7.js"><link rel="prefetch" href="/assets/js/52.8fd32d8d.js"><link rel="prefetch" href="/assets/js/53.8e431eb0.js"><link rel="prefetch" href="/assets/js/54.9d0021b3.js"><link rel="prefetch" href="/assets/js/55.d4597371.js"><link rel="prefetch" href="/assets/js/56.e7c24337.js"><link rel="prefetch" href="/assets/js/57.cebaafd2.js"><link rel="prefetch" href="/assets/js/58.c032a3be.js"><link rel="prefetch" href="/assets/js/59.8d6425ea.js"><link rel="prefetch" href="/assets/js/6.d11ab2bc.js"><link rel="prefetch" href="/assets/js/60.2473c6a1.js"><link rel="prefetch" href="/assets/js/61.06731f0f.js"><link rel="prefetch" href="/assets/js/62.6768c8eb.js"><link rel="prefetch" href="/assets/js/63.b254a74b.js"><link rel="prefetch" href="/assets/js/64.71a120f4.js"><link rel="prefetch" href="/assets/js/65.8f17bb4b.js"><link rel="prefetch" href="/assets/js/66.14537b3a.js"><link rel="prefetch" href="/assets/js/67.104aba91.js"><link rel="prefetch" href="/assets/js/68.48e529b1.js"><link rel="prefetch" href="/assets/js/69.e7933eb7.js"><link rel="prefetch" href="/assets/js/7.985c2a50.js"><link rel="prefetch" href="/assets/js/70.b149e142.js"><link rel="prefetch" href="/assets/js/71.060a0369.js"><link rel="prefetch" href="/assets/js/8.a6c2d7dd.js"><link rel="prefetch" href="/assets/js/9.3f209b21.js"><link rel="prefetch" href="/assets/js/vuejs-paginate.b7eade15.js">
    <link rel="stylesheet" href="/assets/css/0.styles.9139df2e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/images/k.png" alt="KEITH KWON" class="logo"> <span class="site-name can-hide">KEITH KWON</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/wiki/" class="nav-link router-link-active">
  Wiki
</a></div><div class="nav-item"><a href="/portfolio/" class="nav-link">
  Portfolio
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/wiki/" class="nav-link router-link-active">
  Wiki
</a></div><div class="nav-item"><a href="/portfolio/" class="nav-link">
  Portfolio
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Computer Science</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/wiki/computer-science/" class="sidebar-link">Computer Science</a></li><li><a href="/wiki/aws/" class="sidebar-link">AWS- Cloud Computing Setting</a></li><li><a href="/wiki/computer-architecture/" class="sidebar-link">Computer Architecture</a></li><li><a href="/wiki/os/" class="sidebar-link">Operating System</a></li><li><a href="/wiki/system-programming/" aria-current="page" class="active sidebar-link">System Programming</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/wiki/system-programming/#linux-files" class="sidebar-link">Linux Files</a></li><li class="sidebar-sub-header"><a href="/wiki/system-programming/#linux-process" class="sidebar-link">Linux Process</a></li><li class="sidebar-sub-header"><a href="/wiki/system-programming/#linux-권한" class="sidebar-link">Linux 권한</a></li><li class="sidebar-sub-header"><a href="/wiki/system-programming/#shell-사용법" class="sidebar-link">Shell 사용법</a></li><li class="sidebar-sub-header"><a href="/wiki/system-programming/#ls와-파일권한" class="sidebar-link">ls와 파일권한</a></li><li class="sidebar-sub-header"><a href="/wiki/system-programming/#redirection-and-pipe" class="sidebar-link">Redirection and pipe</a></li><li class="sidebar-sub-header"><a href="/wiki/system-programming/#foreground-and-background-process" class="sidebar-link">foreground and background process</a></li><li class="sidebar-sub-header"><a href="/wiki/system-programming/#프로세스-관리-및-제어" class="sidebar-link">프로세스 관리 및 제어</a></li><li class="sidebar-sub-header"><a href="/wiki/system-programming/#리눅스-파일-시스템" class="sidebar-link">리눅스 파일 시스템</a></li><li class="sidebar-sub-header"><a href="/wiki/system-programming/#리눅스-파일-시스템-탐색" class="sidebar-link">리눅스 파일 시스템 탐색</a></li><li class="sidebar-sub-header"><a href="/wiki/system-programming/#하드-링크" class="sidebar-link">하드 링크</a></li><li class="sidebar-sub-header"><a href="/wiki/system-programming/#소프트-링크" class="sidebar-link">소프트 링크</a></li><li class="sidebar-sub-header"><a href="/wiki/system-programming/#특수파일" class="sidebar-link">특수파일</a></li><li class="sidebar-sub-header"><a href="/wiki/system-programming/#시스템콜과-api" class="sidebar-link">시스템콜과 API</a></li><li class="sidebar-sub-header"><a href="/wiki/system-programming/#abi와-표준" class="sidebar-link">ABI와 표준</a></li><li class="sidebar-sub-header"><a href="/wiki/system-programming/#pid" class="sidebar-link">PID</a></li><li class="sidebar-sub-header"><a href="/wiki/system-programming/#pid-system-call" class="sidebar-link">PID &amp; System Call</a></li><li class="sidebar-sub-header"><a href="/wiki/system-programming/#process-생성" class="sidebar-link">Process 생성</a></li><li class="sidebar-sub-header"><a href="/wiki/system-programming/#fork" class="sidebar-link">Fork</a></li><li class="sidebar-sub-header"><a href="/wiki/system-programming/#exec" class="sidebar-link">Exec</a></li><li class="sidebar-sub-header"><a href="/wiki/system-programming/#wait" class="sidebar-link">wait</a></li><li class="sidebar-sub-header"><a href="/wiki/system-programming/#copy-on-wirte" class="sidebar-link">copy on wirte</a></li><li class="sidebar-sub-header"><a href="/wiki/system-programming/#exit" class="sidebar-link">exit</a></li><li class="sidebar-sub-header"><a href="/wiki/system-programming/#메모리와-mmap" class="sidebar-link">메모리와 mmap</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Algorithm</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Network</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Javascript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Design</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>React</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Unity</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>ETC</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="system-programming"><a href="#system-programming" class="header-anchor">#</a> System Programming</h1> <h1 id="_1-linux"><a href="#_1-linux" class="header-anchor">#</a> 1. LINUX</h1> <h3 id="특징"><a href="#특징" class="header-anchor">#</a> 특징</h3> <ul><li>서버/클라우드에 많이 사용되는 운영체제</li> <li>kernel + shell + system처럼 기본 프로그램만 설치되어있는 리눅스를 사용하면 c언어를 컴파일 하는것도 굉장히 빨라진다. 윈도우에서 네시간 걸리면 compile이 리눅스에서는 10분이면 될 수도 있다.</li> <li>UNIX 계열이다.</li> <li>프로그래머 스타일이다.</li> <li>plain하게 프로그래밍이 가능하다.
<ul><li>C언어도 몇가지가 있다.</li> <li>ANSI C가 표준인데 리눅스에서 쓸 수 있다.</li></ul></li></ul> <h3 id="history"><a href="#history" class="header-anchor">#</a> History</h3> <ul><li><p>Linus Torvalds</p> <ul><li>가 유닉스를 기반으로 개발</li> <li>다중 사용자, 다중 작업(시분할 시스템, 멀티 태스킹)을 지원하는 유닉스와 유사</li></ul></li> <li><p>GNU 프로젝트 : GNU is not Unix</p> <ul><li><p>유닉스는 여러 회사에서 각자 개발, 소스를 공유하지 않았다.</p></li> <li><p>리차드 스톨만 : 상호협력 문화로 돌아갈 것을 주장하며 GNU 선언문을 발표</p></li> <li><p>유닉스를 대체할 수 있는 공개돼있는 운영체제를 만들자! 그리고 이를 위해 Free Software Foundation 설립과 GNU Public License 규약을 만든다.</p></li> <li><p>GPL : 기술은 공유하고 마음대로 수정 업데이트 가능하다. 그러나 새로 만든 기술은 마찬가지로 GPL을 따라야 한다.</p></li> <li><p>운영체제 커널 개발 시도 : GNU Hurd.</p> <p>![image-20210509025719523](./System Programming.assets/image-20210509025719523.png)</p></li> <li><p>운영체제를 만들기 위해선 만들어야 할 레이어들이 굉장히 많다.</p></li> <li><p><code>vi</code> : 유닉스 계열의 에디터. improved 버전은<code>vim</code>이라고 불린다.</p></li> <li><p>라이브러리, 컴파일러, 에디터, 쉘 이런것들을 다 만들어 줘야 유닉스를 대체할 수 있다.</p></li></ul></li> <li><p>GNU Project X Linux</p> <ul><li>핵심인 커널 개발이 계속 지연된다.</li> <li>이때 리누스 토발즈가 리눅스 커널 소스를 오픈한다.</li> <li>리차트 스톨만의 GNU 프로젝트 산출물과 리눅스OS를 합치게 된다.</li> <li>GNU도 열심히 만들었는데 억울하게 다들 리눅스라고만 불러서 스톨만이 슬퍼한다.</li></ul></li></ul> <h2 id="linux-files"><a href="#linux-files" class="header-anchor">#</a> Linux Files</h2> <ul><li>모든것은 파일이라는 철학이 있다.
<ul><li>모든 인터렉션은 파일 I/O처럼 다루어진다. 외부디바이스도!</li></ul></li> <li>File Namespace
<ul><li>윈도우 : A드라이브, C드라이브</li> <li>리눅스 : 전역 네임스페이스
<ul><li>/media/floppy/</li></ul></li></ul></li> <li>파일은 inode 고유값과 자료구조에 의해 주요 정보 관리</li></ul> <h2 id="linux-process"><a href="#linux-process" class="header-anchor">#</a> Linux Process</h2> <ul><li>리눅스 실행 파일 : ELF(Executable and Linkable format)
<ul><li>프로세스의 구조(stack, heap, text, data, bss 등을 정의한다)</li></ul></li> <li>다양한 시스템 리소스
<ul><li>시스템콜 호출을 통해 리소스 처리 관리 가능
<ul><li>타이머, 시그널, 파일, 네트워크, 디바이스, IPC</li></ul></li></ul></li> <li>가상 메모리 지원</li> <li>프로세는 pid(프로세스ID) 고유값을 구분. (파일은 inode)</li> <li>init 프로세스(첫번째 프로세스)를 기반으로 fork() 시스템콜을 해서 부모자식 관계로 신규 프로세스를 만든다.</li></ul> <h2 id="linux-권한"><a href="#linux-권한" class="header-anchor">#</a> Linux 권한</h2> <ul><li>시분할 시스템이여서 다중 사용자 접속이 가능하다.</li> <li>이를 사용자/그룹으로 나누어서 권한을 나눠줄 수 있다.</li> <li>root라는 기본 아이디가 있어서 이게 슈퍼관리자다.
<ul><li>해커들의 최대 목표는 root관리자를 획득하는 것</li></ul></li> <li>파일마다 사용자/그룹에 대해
<ul><li>read, write, execute의 권한을 관리한다.</li> <li>접근 권한 정보는 inode의 자료구조에 저장된다.</li></ul></li></ul> <h1 id="_2-ubuntu"><a href="#_2-ubuntu" class="header-anchor">#</a> 2. Ubuntu</h1> <blockquote><p>aws에서 진행</p></blockquote> <h1 id="_3-shell"><a href="#_3-shell" class="header-anchor">#</a> 3. Shell</h1> <h2 id="shell-사용법"><a href="#shell-사용법" class="header-anchor">#</a> Shell 사용법</h2> <ul><li>shell : 사용자와 운영체제간 인터페이스
<ul><li>사용자의 명령 해석 - 시스템콜 호출  - 커널에 명령</li> <li>cli 혹은 gui 가 존재</li></ul></li></ul> <p>![image-20210509164746673](./System Programming.assets/image-20210509164746673.png)</p> <ul><li>이 중 bash를 배우겠습니다.</li></ul> <h3 id="다중-사용자-지원-명령어"><a href="#다중-사용자-지원-명령어" class="header-anchor">#</a> 다중 사용자 지원 명령어</h3> <ul><li>UNIX는 시분할 시스템을 통해 다중 사용자를 지원한다.</li> <li><code>whoami</code> : 아이디 알기</li> <li><code>passwd</code> : id의 패스워드를 바꾼다. aws로 만든 ec2 ubuntu에서는 pw설정이 되어있지 않아서 잘 모르겠다.</li> <li><code>useradd</code> : 기본 설정을 자동으로 하지 않는다.</li> <li><code>adduser</code> : 기본 설정을 자동으로 한다. 이걸 기본으로 쓴다.
<ul><li>id를 만들면 해당 아이디 디렉토리가 /home/ 밑에 만들어진다. useradd하면 이게 안 만들어지고 기타 설정들도 안 만들어진다. adduser를 해보자. root가 아니면 안된다.</li></ul></li> <li><code>sudo</code> : root권한으로 실행한다. root 계정으로 로그인 하지 않은 상태에서 가능하다.
<ul><li>특정 유저들만 <code>sudo</code>를 사용할 수 있게 설정한다. <code>ubuntu</code> 유저는 사용 가능하다.</li> <li><code>/etc/sudoers</code> 파일에서 설정 변경 가능</li> <li>여기에 ![image-20210509174015222](./System Programming.assets/image-20210509174015222.png)</li> <li>추가해주면 이제 keith 도 sudo 가능</li> <li>왜 그냥 <code>root</code>를 안쓰냐? <code>sudo</code>쓰면서 주의하란 말임.</li></ul></li> <li><code>/home/user/.bashrc</code>, <code>/home/user/.profile</code> : 사용자의 기본 설정이 있다.</li> <li><code>su</code> :
<ul><li><code>su root</code> : 현재 사용자 환경설정 기반(.bashrc, .profile) root로 변경</li> <li><code>su - root</code> : 변경 사용자 환경설정 기반 root로 변경</li></ul></li> <li><code>shift v</code> : 한줄 선택
<ul><li><code>y</code> 복사</li> <li><code>p</code> 붙여넣기</li></ul></li> <li><code>man ls</code> : 를 쳐서 옵션들을 볼 수 있다 (manual)</li> <li><code>cat</code> : vi를 쓰지 않고 터미널에서 바로 내용을 본다.</li> <li><code>head</code>, <code>tail</code> : cat과 비슷한데 첫 10줄, 끝 10줄만 본다.</li> <li><code>more</code> : 한 화면에 꽉 차게만 띄우고 space누를때마다 페이지, 엔터누를때마다 한줄씩 넘길 수 있다.</li> <li><code>rm</code> : remove. 조심해야된다. 그냥 삭제됨. 리눅스엔 휴지통이 없다.</li> <li><code>rm -rf 디렉토리명</code> : recursive force 로 하위폴더 전부다 삭제</li></ul> <h2 id="ls와-파일권한"><a href="#ls와-파일권한" class="header-anchor">#</a> ls와 파일권한</h2> <p>![image-20210509174807799](./System Programming.assets/image-20210509174807799.png)</p> <p>![image-20210509175036976](./System Programming.assets/image-20210509175036976.png)</p> <ul><li>1칸 / 3칸 / 3칸 / 3칸</li> <li>파일이면 <code>-</code> 디렉토리면 <code>d</code></li> <li>소유자 / 그룹 / 공개</li> <li>읽기 / 쓰기 / 실행</li></ul> <h3 id="chmod-change-mod"><a href="#chmod-change-mod" class="header-anchor">#</a> chmod (change mod)</h3> <p>![image-20210509175617337](./System Programming.assets/image-20210509175617337.png)</p> <p>![image-20210509175728298](./System Programming.assets/image-20210509175728298.png)</p> <p>![image-20210509175759282](./System Programming.assets/image-20210509175759282.png)</p> <ul><li><code>-R</code> <code>directory</code> : directory 하위의 모든 파일들에게 설정. r은 <code>recursive</code></li></ul> <h3 id="chown-change-owner"><a href="#chown-change-owner" class="header-anchor">#</a> chown (change owner)</h3> <p>![image-20210509180510646](./System Programming.assets/image-20210509180510646.png)</p> <ul><li>그룹이 빈경우는 사용자의 default 그룹 적용</li> <li>사용자가 빈경우 사용자의 default 그룹 적용</li></ul> <h2 id="redirection-and-pipe"><a href="#redirection-and-pipe" class="header-anchor">#</a> Redirection and pipe</h2> <h3 id="standard-stream"><a href="#standard-stream" class="header-anchor">#</a> Standard Stream</h3> <ul><li>command로 실행되는 프로세스는 세가지 stream이 있다.
<ul><li>stdin : standard input stream</li> <li>stdout : standard output stream</li> <li>stderr : standard error stream</li></ul></li> <li>모든 스트림은 plain text로 console에 출력된다.</li></ul> <h3 id="redirection"><a href="#redirection" class="header-anchor">#</a> redirection</h3> <ul><li>표준 스트림의 흐름을 바꿀수 있다.
<ul><li><code>&lt;</code> ,<code>&gt;</code> 를 사용함</li> <li>출력의 방향을 바꿀 수 있다.</li> <li>명령어 표준 출력을 화면이 아니라 파일에 쓰고 싶을때!
<ul><li><code>ls &gt; files.txt</code>ls내용을 files.txt에 쓰고 싶다.  파일이 없으면 만들어 준다.</li> <li><code>ls &gt;&gt; files.txt</code> 현존하는 files.txt의 뒤에 내용을 추가해준다.</li></ul></li></ul></li></ul> <h3 id="pipe"><a href="#pipe" class="header-anchor">#</a> pipe</h3> <blockquote><p>프로세스간 통신에 씌였던 파이프. 근데 여기선 redir과 연결해서 생각하고 ipc와 연결해서 생각하지 않아도 된다.</p></blockquote> <ul><li><p>한 프로세스의 출력 스트림을 다른 프로세스의 입력 스트림으로 사용할 때</p> <p>![image-20210510162309284](./System Programming.assets/image-20210510162309284.png)</p></li> <li><p><code>ls | grep files.txt</code> : ls 명령 출력이 grep 명령 입력스트림으로 들어감</p> <ul><li><p><code>grep</code> : 입력 키워드를 찾는 명령어</p></li> <li><p><code>ls | grep issue</code> : issue라는 단어가 있는 ls결과를 찾는다.</p></li> <li><p>![image-20210510163059795](./System Programming.assets/image-20210510163059795.png)</p></li> <li><p><code>grep -i sometext</code> 식으로 많이 쓰인다.</p> <p>![image-20210510163421907](./System Programming.assets/image-20210510163421907.png)</p></li></ul></li></ul> <h2 id="foreground-and-background-process"><a href="#foreground-and-background-process" class="header-anchor">#</a> foreground and background process</h2> <blockquote><p>폰 노이만 구조에 의해 실행 파일은 모두 메모리에 우선 올라간다. 코드 이미지 또는 바이너리를 실행파일이라고 하고 실행 중인 프로그램은 프로세스라고 한다.</p></blockquote> <ul><li><p>프로세스에는 다음과 같은 상태 정보가 있다.</p> <ul><li>가상 메모리 및 물리 메모리 정보</li> <li>시스템 리소스 관련 정보</li> <li>스케쥴링 단위</li></ul></li> <li><p>리눅스는 기본적으로 다양한 프로세스가 실행된다 . 유닉스의 철학이 여러 프로그램이 서로 유기적으로 각자의 일을 수행하면서 전체시스템이 동작하도록 하는 모델이기 때문.</p></li></ul> <h3 id="foreground-process"><a href="#foreground-process" class="header-anchor">#</a> foreground process</h3> <ul><li>기본적으로 터미널에서 실행하는 모든 것. 프로세스 수행 종료까지 사용자가 다른 입력을 하지 못한다.</li></ul> <h3 id="background-process"><a href="#background-process" class="header-anchor">#</a> background process</h3> <ul><li>사용자 입력관 상관없이 실행됨.</li> <li>실행하고 뒤에 <code>&amp;</code>를 붙여주면 백그라운드로 실행되며 백그라운드 job 번호와 PID가 뜬다.</li> <li>ps를 쳐서 백그라운드에 실행됨을 확인할 수 있다.</li></ul> <p>![image-20210510194034435](System Programming.assets/image-20210510194034435.png)</p> <h2 id="프로세스-관리-및-제어"><a href="#프로세스-관리-및-제어" class="header-anchor">#</a> 프로세스 관리 및 제어</h2> <ul><li><p><code>ctrl z</code> : 프로세스를 중단한다.</p></li> <li><p><code>jobs</code> : bg프로세스들을 보여준다.</p> <ul><li>![image-20210510194626367](./System Programming.assets/image-20210510194626367.png)</li></ul></li> <li><p><code>bg</code> : 최근에 중단되 bg프로세스를 실행한다.</p></li> <li><p><code>ctrl c</code> : 프로세스를 죽인다.</p></li> <li><p><code>ps</code> : 프로세스 상태 확인</p></li> <li><p><code>kill -9 pid</code> 하면 프로세스 죽이기 가능. -9는 force의 뜻</p></li> <li><p><code>kill %jobnumber</code> 해도된다.</p> <p>![image-20210510195204132](./System Programming.assets/image-20210510195204132.png)</p></li> <li><p>프로세스 중 <code>웹서버</code>가 있는데 이런건 24시간 돌아간다. 데몬 중 하나임.</p></li></ul> <h2 id="리눅스-파일-시스템"><a href="#리눅스-파일-시스템" class="header-anchor">#</a> 리눅스 파일 시스템</h2> <blockquote><p>모든 것은 파일이다. -unix</p></blockquote> <ul><li>마우스, 키보드, 마이크 이런것도 전부 파일과 같이 다루어짐</li> <li>모든 자원에 대해 추상화 인터페이스로 파일 인터페이스를 활용한다.</li> <li><code>cd /dev</code> : 에 가면 device들을 볼 수 있다.
<ul><li><code>tty</code> : 터미널. 가상 파일 시스템 인터페이스를 통해 가상 터미널(가상 디바이스)에 연결돼있다.</li></ul></li></ul> <h3 id="슈퍼-블록-super-block"><a href="#슈퍼-블록-super-block" class="header-anchor">#</a> 슈퍼 블록(super block)</h3> <p>![image-20210510214157519](./System Programming.assets/image-20210510214157519.png)</p> <ul><li>슈퍼 블록 : 파일시스템에 관한 정보가 있다. 전체 사이즈, 어떤 파일시스템 알고리즘인가?</li> <li>파일이름과 inode는 매핑되어 있다. 프로세스와 pid가 매핑되어 있듯이</li> <li>![image-20210510214415566](./System Programming.assets/image-20210510214415566.png)</li></ul> <h2 id="리눅스-파일-시스템-탐색"><a href="#리눅스-파일-시스템-탐색" class="header-anchor">#</a> 리눅스 파일 시스템 탐색</h2> <h3 id="inode"><a href="#inode" class="header-anchor">#</a> inode</h3> <ul><li>리눅스 파일 탐색 (/home/ubuntu/link.txt)
<ul><li>각 디렉토리 엔트리(dentry) 탐색
<ul><li>엔트리는 해당 디렉토리 파일/디렉토리 정보가 있다.</li></ul></li> <li>'/' dentry 에서 'home'을 찾고, 'home' dentry에서 'ubuntu'를 찾고, 'ubuntu' dentry 에서 link.txt 파일이름에 매핑돼있는 inode를 찾는다.</li> <li>Each dentry maps an inode number to a file name and a parent directory.</li></ul></li></ul> <p>![image-20210511085303705](./System Programming.assets/image-20210511085303705.png)</p> <ul><li>home 아래에 내 계정</li> <li>media, mnt : 디바이스, 추가 ssd</li> <li>etc : 다양한 설정 파일들</li> <li>dev : 마우스 / 키보드 / 터미널</li> <li>bin, sbin : 쉘 명령어의 실행 파일들. 'PATH'설정 돼 ㅇㅆ음</li> <li>boot : 부팅 관련</li> <li>var/log : 로그파일들 생김. 서버 쓰면 자주 씀.</li></ul> <h2 id="하드-링크"><a href="#하드-링크" class="header-anchor">#</a> 하드 링크</h2> <blockquote><p>링크는 유닉스 시스템에만 있는 독특한 기능이다.</p></blockquote> <ul><li><code>cp</code>  명령어 : copy
<ul><li><code>cp link.txt link3.txt</code> : link.txt를 복사해서 link3.txt를 만든다</li></ul></li> <li><code>rm</code> 명령어 : remove
<ul><li><code>rm link3.txt</code></li></ul></li> <li><code>ln</code> : 하드링크
<ul><li>윈도우에 바로가기가 있다면 unix에서는 링크가 있다.</li></ul></li> <li><code>ln link.txt hard.txt</code> 를 하게되면 <code>hard.txt</code>가 생긴다.
<ul><li>카피와 같은가? ㄴㄴ 동일한 inode번호와 데이터를 가지고 있다.</li> <li>![image-20210511091431375](./System Programming.assets/image-20210511091431375.png)</li> <li>카피는 inode가 다른 번호가 생긴다.</li> <li>원본 변경시 링크도 당연히 변경</li> <li>원본 삭제시 <strong>링크는 그대로 있다</strong> <ul><li>![image-20210511092049892](./System Programming.assets/image-20210511092049892.png)</li> <li>링크도 원본만큼 유효한 포인터이기 때문</li></ul></li></ul></li></ul> <h2 id="소프트-링크"><a href="#소프트-링크" class="header-anchor">#</a> 소프트 링크</h2> <ul><li><code>ln -s link.txt softlink.txt</code> : -s를 붙여서 소프트링크를 해준다.</li> <li>윈도우의 바로가기와 더 비슷하다</li> <li>소프트링크는 inode 값이 다르다!</li> <li>원본 삭제시 소프트링크는 같이 삭제된다.</li> <li>별도의 inode이며 여기에 저장된 address는 원본파일의 inode이다.</li> <li>하드링크는 원본파일과 동일한 inode</li></ul> <h2 id="특수파일"><a href="#특수파일" class="header-anchor">#</a> 특수파일</h2> <ul><li>디바이스
<ul><li>블록 디바이스 : HDD, CD/DVD처럼 블록/섹터 단위로 데이터 송신, IO 송수신 속도 높다.</li> <li>케릭터 디바이스 : 키보드, 마우스 같은 바이트 단위 데이터. 손수신 속도가 낮다.</li></ul></li></ul> <h1 id="_4-system-programming"><a href="#_4-system-programming" class="header-anchor">#</a> 4. System Programming</h1> <h2 id="시스템콜과-api"><a href="#시스템콜과-api" class="header-anchor">#</a> 시스템콜과 API</h2> <h3 id="시스템콜"><a href="#시스템콜" class="header-anchor">#</a> 시스템콜</h3> <ul><li>시스템 콜 : 사용자 영역에서 커널 영역으로 들어가는 함수
<ul><li>여러 라이브러리(api)로 이뤄져있다.</li> <li>리눅스/유닉스는 c언어로 만들어져 있다.</li> <li>how does it work
<ul><li>cpu가 커널 모드로 바뀜</li> <li>instruction code(CPU가 제공)로 인터럽트(0x80)를 일으킨다.</li> <li>IDT에서 0x80에 해당하는 함수를 실행. 0x80은 system_call() 이다.</li> <li>![image-20210511110539710](./System Programming.assets/image-20210511110539710.png)</li> <li>함수에서 eax와 ebx 참조</li> <li>eax레지스터에 시스템콜 번호</li> <li>ebx레지스터에 인자값</li> <li>시스템콜 실행</li> <li>![image-20210511110226649](./System Programming.assets/image-20210511110226649.png)</li> <li>사용자모드로 변경</li></ul></li></ul></li> <li>c 라이브러리
<ul><li>커널도 c언어로 이뤄져있다.</li></ul></li> <li>c 컴파일러</li></ul> <h3 id=""><a href="#" class="header-anchor">#</a></h3> <h3 id="api"><a href="#api" class="header-anchor">#</a> API</h3> <ul><li><p>응용 프로그램과 분리된 하위 호환 인터페이스</p> <p>![image-20210511155556865](./System Programming.assets/image-20210511155556865.png)</p></li> <li><p>라이브러리</p> <ul><li><p>동적 라이브러리</p> <ul><li>바이너리가 이미 만들어져 있어서 사용시 여기에 붙여서 쓴다.</li> <li>실행할때 호출하며 실행파일로 컴파일할때는 같이 컴파일 되지 않는다.</li> <li>api는 응용프로그램과 분리되어 있다. 그래서 라이브러리가 따로 업데이트 가능하다. 에러가 날 수도 있겠지만.</li></ul></li> <li><p>정적 라이브러리</p></li> <li><p>대표적 라이브러리</p> <ul><li><p>유닉스 C 라이브러리 : libc</p> <ul><li>cc : c compiler</li></ul></li> <li><p>리눅스 C 라이브러리 : GNU libc,</p> <ul><li><p>gcc : gnu c  compiler</p> <ul><li><p>aws에는 기본설치가 안 되어 있으므로 설치해주자</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>sudo apt-get install gcc
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p><code>gcc -o test.c test</code> : 컴파일</p></li></ul></li></ul></li></ul></li></ul></li></ul> <h2 id="abi와-표준"><a href="#abi와-표준" class="header-anchor">#</a> ABI와 표준</h2> <h3 id="abi-application-binary-interface"><a href="#abi-application-binary-interface" class="header-anchor">#</a> ABI(Application Binary Interface)</h3> <p>![image-20210511160321732](./System Programming.assets/image-20210511160321732.png)</p> <ul><li><p>함수 실행 방식, 레지스터 활용, 시스템 콜 실행, 라이브러리 링크 방식 등</p></li> <li><p>ABI가 호환되면 재컴파일없이 동작</p></li> <li><p>툴체인(컴파일러를 만드는 프로그램)에서 사용된다.</p></li> <li><p>함수의 인자들을 어떤 레지스터에 넣을 것인가? 같은 것을 정해준다.</p> <p>![image-20210511160537397](System Programming.assets/image-20210511160537397.png)</p></li></ul> <h3 id="posix"><a href="#posix" class="header-anchor">#</a> POSIX</h3> <ul><li>API와 ABI를 표준화하려는 시도가 있었다. (IEEE)</li> <li>리차드 스톨만(자유 소프트웨어 재단)이 POSIX를 표준안으로 제안</li></ul> <h3 id="시스템-프로그래밍과-버전"><a href="#시스템-프로그래밍과-버전" class="header-anchor">#</a> 시스템 프로그래밍과 버전</h3> <ul><li>소프트웨어는 계속 업데이트 되지만</li> <li>시스템 레벨단 기술은 70년대부터 꾸준하게 유지가 되고 있다.</li> <li>하위 시스템 레벨을 알고 있는게 중요하다.</li></ul> <h1 id="_5-process-management"><a href="#_5-process-management" class="header-anchor">#</a> 5. Process Management</h1> <h2 id="pid"><a href="#pid" class="header-anchor">#</a> PID</h2> <h3 id="basic"><a href="#basic" class="header-anchor">#</a> Basic</h3> <ul><li>프로그램 : 바이너리, 코드 이미지, 응용 프로그램, application, 또는 실행 파일</li> <li>프로세스 : 현재 실행중인 프로그램(메모리 적재 + 프로세스 상태PCB)</li> <li>스레드
<ul><li>리눅스는 무조건 기본 스레드가 포함된다</li> <li>싱글스레드 : 리눅스는 기본적으로 싱글스레드</li> <li>멀티스레드 : 강제로 여러개 띄운경우</li></ul></li></ul> <h3 id="pid-2"><a href="#pid-2" class="header-anchor">#</a> PID</h3> <ul><li>유니크한 pid</li> <li>부호형 16비트 정수값 -&gt; 최대값은 2^15 = 32768</li> <li>pid 값 한계 때문에 문제가 발생할 수 있다.
<ul><li><code>sudo vi /proc/sys/kernel/pid_max</code></li></ul></li></ul> <h3 id="process-layer"><a href="#process-layer" class="header-anchor">#</a> Process Layer</h3> <ul><li><p>init process's PID = 1</p></li> <li><p>init 프로세스는 운영체제가 만든다.</p></li> <li><p><code>ppid</code>를 통해 부모 프로세스의 pid를 알 수 있다.</p> <ul><li><code>ps -ef</code>를 통해 알 수 있다.</li> <li>e : 시스템 상 모든 프로세스 출력</li> <li>f : UID, PID, PPID&lt; CPU, STIME, TTY, TIME, CMD를 출력</li></ul></li></ul> <h3 id="프로세스와-owner"><a href="#프로세스와-owner" class="header-anchor">#</a> 프로세스와 owner</h3> <ul><li><p><code>sudo vi /etc/passwd</code> : pw뿐만 아니라 uid와 gid도 있다.</p> <p>![image-20210511173615864](./System Programming.assets/image-20210511173615864.png)</p> <ul><li>사용자 : 비밀번호(가려짐):uid:gid</li></ul></li> <li><p><code>sudo vi /etc/shadow</code></p></li></ul> <h2 id="pid-system-call"><a href="#pid-system-call" class="header-anchor">#</a> PID &amp; System Call</h2> <ul><li><code>getpid()</code> : pid를 가져온다.</li> <li><code>getppid()</code> : ppid를 가져온다.</li> <li>둘다 시스템콜을 사용한다.</li></ul> <h2 id="process-생성"><a href="#process-생성" class="header-anchor">#</a> Process 생성</h2> <ul><li>컴파일시 TEXT, DATA, BSS는 만들어지고 실행시 HEAP, STACK이 만들어진다.</li> <li>프로세스 생성 시
<ul><li>전체 메모리 만들어진다</li> <li>TEXT, DATA, BSS 부분(이미지)이 업로드 된다</li> <li>실행하면서 HEAP, STACK이 바뀌어 간다.</li></ul></li> <li>프로세스 계층
<ul><li>부모와 자식 프로세스가 있다.</li></ul></li></ul> <h2 id="fork"><a href="#fork" class="header-anchor">#</a> Fork</h2> <ul><li><p>동일한 코드, 데이터를 가진 프로세스를 만든다</p></li> <li><p>부모 프로세스는 그대로 살아 있다.</p></li> <li><p>자식 생성 시 Program Counter는 같은 위치</p></li> <li><p>리턴 값이 PID이다.</p> <ul><li>PID가 0이면 child</li> <li>아니면 부모여서 실행을 다르게 할 수 있다.</li></ul> <p>![image-20210511182252832](./System Programming.assets/image-20210511182252832.png)</p></li></ul> <p>![image-20210511184358959](./System Programming.assets/image-20210511184358959.png)</p> <h2 id="exec"><a href="#exec" class="header-anchor">#</a> Exec</h2> <ul><li>별도의 새로운 프로세스를 만드는 것이 아니라 현재 공간에 덮어 씌운다.</li> <li>부모 프로세스는 사라진다.</li> <li>새로운 실행 파일!</li></ul> <p>![image-20210509182607408](./System Programming.assets/image-20210509182607408.png)</p> <ul><li>BSS, DATA, TEXT 전부 덮어씌워진다.</li> <li>![image-20210509182639121](./System Programming.assets/image-20210509182639121.png)</li> <li><code>execl(루트부터의디렉토리, argv[0], argv[1]... , NULL)</code></li></ul> <p>![image-20210511183108589](./System Programming.assets/image-20210511183108589.png)</p> <ul><li><code>execlp</code> : path가 들어가있어서 풀 디렉토리를 안 쳐도 된다.</li></ul> <p>![image-20210511183152951](./System Programming.assets/image-20210511183152951.png)</p> <ul><li><code>execle</code> : 환경변수를 사용자가 직접 세팅해서 쓴다. <code>execlp</code>는 기존설정된 path를 사용.</li></ul> <p>![image-20210511183308360](./System Programming.assets/image-20210511183308360.png)</p> <ul><li><code>v</code> 가 붙으면 인자를 variable로 넣는다.</li></ul> <h2 id="wait"><a href="#wait" class="header-anchor">#</a> wait</h2> <ul><li>fork() 함수 호출시 자식프로세스가 종료할때까지 부모 프로세스가 기다림.</li> <li>부모 프로세스가 먼저 죽으며 좀비, 고아 프로세스가 생길 수 있다.</li> <li>shell프로그램들은 전형적으로 이러하다.</li> <li>fork()로 새로운 프로세스 복사후 execl()쓰는 것이 일반적이다.</li> <li>shell자체가 기본적으로 fork를 따고 그 안에서 execl을 돌리는 형태다. wait()가 걸려있어서 꺼지지 않는다.</li></ul> <h2 id="copy-on-wirte"><a href="#copy-on-wirte" class="header-anchor">#</a> copy on wirte</h2> <ul><li><p>리눅스는 프로세스당 4gb의 가상메모리가 할당된다</p> <p>![image-20210509201148106](./System Programming.assets/image-20210509201148106.png)</p></li> <li><p>3~4gb : 커널 스페이스에 운영체제가 들어간다.</p> <ul><li><p>프로세스당 들어갈 필요가 없기 때문에 물리메모리는 동일 영역을 사용한다.</p> <p>![image-20210509201320467](./System Programming.assets/image-20210509201320467.png)</p></li> <li></li></ul></li> <li><p>0~3gb : 유저</p></li> <li><p>fork()는 새로운 프로레스 공간 생성 후 기본 프로세스 공간 복사</p> <ul><li><p>4gb를 복사하면 프로세스 생성시간이 오래 걸린다.</p></li> <li><p>자식 프로세스 생성시, 부모 프로세스의 페이지를 그대로 사용한다.</p></li> <li><p>읽기가 아닌 쓰기를 할때 이때 페이지를 복사하고 분리한다.</p></li> <li><p>이렇게 프로세스 생성 시간을 줄일 수 있고 페이지 수도 최소화 할 수 있다.</p> <p>![image-20210509201841606](./System Programming.assets/image-20210509201841606.png)</p></li> <li></li></ul></li></ul> <h2 id="exit"><a href="#exit" class="header-anchor">#</a> exit</h2> <ul><li><code>exit()</code> 시스템콜 : 프로세스 종류</li> <li>기본 구조 : 부모에서 fork치고 부모는 wait. 자식은 exec하고 부모로 돌아옴. 그 뒤에 뒷처리 함</li> <li>그렇기 때문에 프로세스 종료상태를 알려주는 exit이 필요하다.</li> <li>보통 비정상 종료를 할때 <code>exit</code>을 사용한다.</li> <li>c언어 실행시
<ul><li>사실 <code>int main(){}</code>함수도 <code>start</code>라는 함수 안에 있다. <code>start</code>는 라이브러로 compile될때 바이너리가 붙여져 있다.</li> <li>start함수 내부에서 main이 진행되고 return 값이 나오면 main함수는 종료.</li> <li>start함수의 남은 부분에서 뒷처리가 실행되고 마지막에 있는 exit이 실행되면서 종료된다</li> <li>main함수 안에 exit을 쓰면 거기서 바로 start함수까지 끝나게 된다.</li></ul></li> <li><code>return</code> vs <code>exit</code> <ul><li>exit : 즉시 종료</li> <li>return : main이라는 함수만 종료</li></ul></li> <li><code>exit(EXIT_SUCCESS)</code> or <code>exit(0)</code></li> <li><code>exit(EXIT_FAILURE)</code> or <code>exit(1)</code></li> <li>exit() 시스템콜 내부 동작
<ul><li>atexit() : 종료시 실행될 함수 등록가능</li> <li>IO 스트림 버퍼 삭제(stdin, stdout, stderr)</li> <li>프로세스가 오픈한 파일 모두 종료</li> <li>tmpfile()을 통해 생성한 임시 파일 삭제</li></ul></li></ul> <h1 id="_6-ipc"><a href="#_6-ipc" class="header-anchor">#</a> 6. IPC</h1> <p>![image-20210509190933458](./System Programming.assets/image-20210509190933458.png)</p> <ul><li><p>기본적으로 process간에 정보를 주고 받을 수 없어서 나온게 IPC</p></li> <li><p>File을 만들어서 공유하던가</p></li> <li><p>커널 공간을 공유함으로 주고 받을 수 있다.</p></li> <li><p>기법들</p> <ul><li>file</li> <li>message queue</li> <li>shared memory</li> <li>pipe</li> <li>signal</li> <li>semaphore</li> <li>socket</li></ul></li> <li><p><code>ipcs</code>를 통해 kernel 공간 메모리 확인 가능</p> <p>![image-20210509192747132](./System Programming.assets/image-20210509192747132.png)</p></li></ul> <p>![image-20210509192617961](./System Programming.assets/image-20210509192617961.png)</p> <h3 id="pipe-2"><a href="#pipe-2" class="header-anchor">#</a> pipe</h3> <ul><li>부모 -&gt; 자식. 단방향 통신</li></ul> <p>![image-20210509191159802](./System Programming.assets/image-20210509191159802.png)</p> <ul><li>pipe는 커널에 생성된다.</li></ul> <h3 id="message-queue"><a href="#message-queue" class="header-anchor">#</a> message queue</h3> <ul><li>물리의 커널 영역에 message queue를 만들어서 주고 받는다.</li> <li>양방향 통신이 가능하다.</li></ul> <h3 id="shared-memory"><a href="#shared-memory" class="header-anchor">#</a> shared memory</h3> <ul><li>message queue는 fifo방식인데 이건 그냥 변수처럼 접근 가능하게 한다.</li> <li>공유메모리 key를 갖고 여러 프로세스가 접근 가능하다.</li> <li><code>shmget</code> : 공유메모리를 생성하는 system call</li> <li><code>shmat</code> : 메모리에 매핑</li> <li><code>shmdt</code> : 메모리 해제</li> <li><code>shmctl</code> : 공유 메모리 삭제</li></ul> <h1 id="_7-signal"><a href="#_7-signal" class="header-anchor">#</a> 7. Signal</h1> <ul><li><p>ipc기법처럼 쓰일 수 있지만 그것만으로 한정 할 순 없다.</p></li> <li><p>유닉스에서 30년간 이용</p></li> <li><p>커널 또는 프로세스에서 다른 프로세스에 어떤 이벤트가 발생되었는지를 알려주는 기법</p></li> <li><p><code>ctrl c</code>도 시그널의 한 예다.</p></li> <li><p><code>ctrl z</code> 프로세스를 백그라운드로 바꾼다. 이것도 시그널이다.</p> <p>![image-20210509195647486](./System Programming.assets/image-20210509195647486.png)</p></li> <li><p><code>kill -l</code> : 시그널을 다 볼 수 있다.</p></li></ul> <h3 id="시그널과-프로세스"><a href="#시그널과-프로세스" class="header-anchor">#</a> 시그널과 프로세스</h3> <p>![image-20210509200459210](./System Programming.assets/image-20210509200459210.png)</p> <ul><li>시그널을 순서대로 받아서 대기 시킨다.</li> <li>blocked 64bit. 시그널이 64개여서 각각 막는지 안막는지 설정</li> <li>sig : 어떤 동작을 처리할지 action에 정의돼있다.</li> <li>순서 :
<ul><li>프로세스에 signal 발생 시 : signal 관련 자료구조에 signal이 들어가고</li> <li>프로세스는 각종 시스템콜과 인터럽트에 의해 커널모드로 수시로 바뀐다.</li> <li><strong>사용자모드로 전환하는 시점</strong>에 마지막에 하는 일 중 하나가 시그널을 확인하고 실행해야되면 실행한다.</li></ul></li></ul> <h1 id="_8-shell-script"><a href="#_8-shell-script" class="header-anchor">#</a> 8. Shell Script</h1> <ul><li><p>쉘을 사용해서 프로그래밍</p></li> <li><p>서버작업 및 devops를 위해 필요하다</p></li> <li><p>쉘 명령어에 문법이 추가된 형태</p></li> <li><p>example</p> <ul><li><p>situation</p> <blockquote><p>서버가 다운됨.</p> <p>저장공간이 없음.</p> <p>로그 파일 업데이트가 안되어 프로그램 비정상종료</p> <p>로그파일 누적이 원인</p> <p>로그파일 자동 삭제 방법은?</p></blockquote></li> <li><p>해결</p> <blockquote><p>쉘스크립트 생성 및 주기적 실행(cron tab)</p></blockquote></li></ul></li> <li><p>기본문법</p> <ul><li>파일로 작성 후 파일을 실행</li> <li>가장 첫 라인은 <code>#!/bin/bash</code></li> <li>실행 권한이 필요하다.</li> <li><code>name.sh</code> 형식이다.</li> <li><code>#</code> 은 주석 라인</li> <li>변수
<ul><li>변수명=데이터</li> <li>![image-20210512094504581](./System Programming.assets/image-20210512094504581.png)</li></ul></li></ul></li></ul> <h3 id="리스트-변수"><a href="#리스트-변수" class="header-anchor">#</a> 리스트 변수</h3> <p>![image-20210512095117630](./System Programming.assets/image-20210512095117630.png)</p> <p>리스트 변수를 쓸때는 중괄호를 써줘야 한다.</p> <p>중괄호를 안쓰면 daemons를 변수로 하고(리스트의첫번째만 인식) [1]을 스트링으로 인식한다. 결과 : <code>httpd[1]</code></p> <h3 id="사전-정의된-지역-변수"><a href="#사전-정의된-지역-변수" class="header-anchor">#</a> 사전 정의된 지역 변수</h3> <p>![image-20210512095523535](./System Programming.assets/image-20210512095523535.png)</p> <h3 id="연산자"><a href="#연산자" class="header-anchor">#</a> 연산자</h3> <p>![image-20210512095839696](./System Programming.assets/image-20210512095839696.png)</p> <ul><li>백틱 꼭 쓰고</li> <li>expr로 연산한다</li> <li>숫자와 기호는 다 한칸씩 띄운다.</li> <li>괄호와 곱하기 앞에는 역슬래시를 써야한다.</li></ul> <h3 id="조건문"><a href="#조건문" class="header-anchor">#</a> 조건문</h3> <p>![image-20210512171513385](./System Programming.assets/image-20210512171513385.png)</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>if [ 조건 ]
then
	명령문
fi
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>![image-20210512170907867](./System Programming.assets/image-20210512170907867.png)</p> <p>![image-20210512170933316](./System Programming.assets/image-20210512170933316.png)</p> <p>![image-20210512171054044](./System Programming.assets/image-20210512171054044.png)</p> <p>![image-20210512171450358](./System Programming.assets/image-20210512171450358.png)</p> <h3 id="ping"><a href="#ping" class="header-anchor">#</a> ping</h3> <ul><li>IP주소가 서버를 가르킨다.</li> <li>핑은 연결돼있는 컴퓨터가 살아있는지 확인한다.</li> <li>확인 요청을 보내면 살아있으면 응답이 온다.</li> <li><code>ping -c 1 192.168.0.1 1&gt; /dev/null</code> <ul><li>-c : 한번만 확인해라. 안하면 초당 몇회씩 확인함</li> <li>0 표준입력, 1 표준출력, 2표준에러</li> <li><code>$?</code> : 마지막 결과값</li></ul></li></ul> <div class="language-sh line-numbers-mode"><pre class="language-sh"><code><span class="token shebang important">#!/bin/bash</span>
<span class="token function">ping</span> -c <span class="token number">1</span> <span class="token number">192.169</span>.0.1 <span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span> /dev/null
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$?</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">]</span>
<span class="token keyword">then</span>
        <span class="token builtin class-name">echo</span> <span class="token string">'핑성공!'</span>
<span class="token keyword">else</span>
        <span class="token builtin class-name">echo</span> <span class="token string">'핑실패!'</span>
<span class="token keyword">fi</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="for"><a href="#for" class="header-anchor">#</a> for</h3> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token shebang important">#!/bin/bash</span>
<span class="token keyword">for</span> <span class="token for-or-select variable">database</span> <span class="token keyword">in</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">ls</span><span class="token variable">)</span></span>
<span class="token keyword">do</span>
        <span class="token builtin class-name">echo</span> <span class="token variable">$database</span>
<span class="token keyword">done</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="while"><a href="#while" class="header-anchor">#</a> while</h3> <p>![image-20210512172518830](./System Programming.assets/image-20210512172518830.png)</p> <h3 id="예제-백업하기"><a href="#예제-백업하기" class="header-anchor">#</a> 예제 - 백업하기</h3> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token shebang important">#!/bin/bash</span>

<span class="token keyword">if</span> <span class="token punctuation">[</span> -z <span class="token variable">$1</span> <span class="token punctuation">]</span><span class="token operator">||</span><span class="token punctuation">[</span> -z <span class="token variable">$2</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
        <span class="token builtin class-name">echo</span> usage: <span class="token variable">$0</span> sourcedir targetdir
<span class="token keyword">else</span>
        <span class="token assign-left variable">SRCDIR</span><span class="token operator">=</span><span class="token variable">$1</span>
        <span class="token assign-left variable">DSTDIR</span><span class="token operator">=</span><span class="token variable">$2</span>
        <span class="token assign-left variable">BACKUPFILE</span><span class="token operator">=</span>backup.<span class="token variable"><span class="token variable">$(</span><span class="token function">date</span> +%y%m%d%H%M%S<span class="token variable">)</span></span>.tar.gz
        <span class="token keyword">if</span> <span class="token punctuation">[</span> -d <span class="token comment">#DSTDIR ]; then</span>
                <span class="token function">tar</span> -cvzf <span class="token variable">$DSTDIR</span>/<span class="token variable">$BACKUPFILE</span> <span class="token variable">$SRCDIR</span>
        <span class="token keyword">else</span>
                <span class="token function">mkdir</span> <span class="token variable">$DSTDIR</span>
                <span class="token function">tar</span> -cvzf <span class="token variable">$DSTDIR</span>/<span class="token variable">$BACKUPFILE</span> <span class="token variable">$SRCDIR</span>
        <span class="token keyword">fi</span>
<span class="token keyword">fi</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><ul><li>인자로 $1 과 $2 두개를 받는다. 제대로 안오면 사용법만 인쇄</li> <li><code>date</code>라는 함수로 시간 가져온다 : backup.현재시각.tar.gz</li> <li><code>-d</code> 로 디렉토리가 현재 있는지 없는지 판단한다</li> <li><code>tar</code> : 70년대부터 있던 압축명령. 원래는 묶기만 했는데 이제 압축도 한다.
<ul><li>x : 묶음 해제</li> <li>c : 파일 묶음</li> <li>v : 과정을 화면에 표시</li> <li>z : gunzip 사용</li> <li>f : 파일 이름 지정</li> <li>주요 옵션
<ul><li><code>tar -cvzf [압축된 파일 이름] [압축할 파일이나 폴더]</code></li> <li><code>tar -xvzf [압축해제할 이름]</code></li></ul></li> <li></li></ul></li></ul> <h3 id="예제-로그파일-정리하기"><a href="#예제-로그파일-정리하기" class="header-anchor">#</a> 예제 - 로그파일 정리하기</h3> <ul><li>정책
<ul><li>로그파일 2일 이상 -&gt; 압축</li> <li>압축파일 3일 이상 -&gt; 삭제</li></ul></li></ul> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token shebang important">#!/bin/bash</span>

<span class="token assign-left variable">LOGDIR</span><span class="token operator">=</span>/var/log
<span class="token assign-left variable">GZIPDAY</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token assign-left variable">DELDAY</span><span class="token operator">=</span><span class="token number">2</span>
<span class="token builtin class-name">cd</span> <span class="token variable">$LOGDIR</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;cd <span class="token variable">$LOGDIR</span>&quot;</span>

<span class="token function">sudo</span> <span class="token function">find</span> <span class="token builtin class-name">.</span> -type f -name <span class="token string">'*.log.?'</span> -mtime +<span class="token variable">$GZIPDAY</span> -exec <span class="token function">bash</span> -c <span class="token string">&quot;gzip {}&quot;</span> <span class="token punctuation">\</span><span class="token punctuation">;</span> <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>
<span class="token function">sudo</span> <span class="token function">find</span> <span class="token builtin class-name">.</span> -type f -name <span class="token string">'*.gz'</span> -mtime +<span class="token variable">$DELDAY</span> -exec <span class="token function">bash</span> -c <span class="token string">&quot;rm -f {}&quot;</span> <span class="token punctuation">\</span> <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><ul><li><code>find</code> : 찾기.</li> <li><code>.</code> : 현재폴더</li> <li><code>-type f</code> : 디렉토리가 아닌 파일들만</li> <li><code>*</code> : 아무 str</li> <li><code>?</code> : 한글자 (참고:정규표현식)</li> <li><code>-mtime +$GZIPDAY</code> : 2일 이상된 파일 검색</li> <li><code>-exec bash -c &quot;명령어1; 명령어2&quot;;</code>: 파일들에 해당 명령어 실행</li></ul> <h1 id="_9-thread"><a href="#_9-thread" class="header-anchor">#</a> 9. Thread</h1> <h3 id="thread란"><a href="#thread란" class="header-anchor">#</a> Thread란?</h3> <ul><li>프로세스 내에서 실제로 작업을 수행하는 주체</li> <li>프로세스 안에는 한개 이상의 스레드가 작업을 수행</li> <li>스택과 PC register는 독립적으로 할당된다.</li> <li>커널의 도움 없이 상호 통신 가능. -&gt; 동기화 문제를 해결해야한다.</li></ul> <p>![image-20210512185718031](./System Programming.assets/image-20210512185718031.png)</p> <h3 id="pthread란"><a href="#pthread란" class="header-anchor">#</a> Pthread란?</h3> <ul><li>POSIX Thread</li> <li>저수준 API 100개 함수 제공</li> <li>핵심 라이브러리</li> <li>다른 스레드도 Pthread기반으로 구현</li></ul> <h3 id="pthread-라이브러리"><a href="#pthread-라이브러리" class="header-anchor">#</a> Pthread 라이브러리</h3> <ul><li><p><code>&lt;phtread.h&gt;</code> 헤더파일</p></li> <li><p>함수는 <code>pthread_</code>로 시작</p></li> <li><p>그룹</p> <ul><li>스레드 관리 : 생성, 종료, 조인, 디태치</li> <li>동기화 : 뮤텍스 등 동기화 관련 함수</li></ul></li> <li><p>glibc와 분리된 libpthread 라이브러리에 구현되어서 컴파일시 명시해줘야한다.</p> <p><code>gcc -pthread test.c -o test</code></p></li></ul> <h3 id="thread-생성"><a href="#thread-생성" class="header-anchor">#</a> thread 생성</h3> <h3 id="thread-종료"><a href="#thread-종료" class="header-anchor">#</a> thread  종료</h3> <blockquote><p>보통 잘 안쓴다. 알아서 종료되기 때문.</p></blockquote> <h3 id="thread-조인"><a href="#thread-조인" class="header-anchor">#</a> thread 조인</h3> <blockquote><p>특정 thread가 끝날때까지 기다려주는 함수</p></blockquote> <h3 id="thread-디태치"><a href="#thread-디태치" class="header-anchor">#</a> thread 디태치</h3> <blockquote><p>스레드 종료시 즉시 관련 리스소 해제. 조인을 기다리지 않고 종료 즉시 해제.</p></blockquote> <ul><li>종료 후 상태값으로 후처리를 안하면 디태치, 사용하면 조인.</li> <li>detach를 했다고 다음 코드들이 join처럼 기다리지 않고 그대로 실행된다.</li></ul> <p>![image-20210513015121091](./System Programming.assets/image-20210513015121091.png)</p> <h3 id="mutex"><a href="#mutex" class="header-anchor">#</a> mutex</h3> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>phthread_mutex_t mutex_lock <span class="token operator">=</span> PTHREAD_MUTEX_INITIALIZER<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>자원을 독점할수 있게 해준다.</p> <h1 id="_10-system-programming-advanced"><a href="#_10-system-programming-advanced" class="header-anchor">#</a> 10. System Programming Advanced</h1> <h2 id="메모리와-mmap"><a href="#메모리와-mmap" class="header-anchor">#</a> 메모리와 mmap</h2> <ul><li><p><code>malloc</code> : heap 영역에 동적 메모리를 생성한다.</p></li> <li><p><code>free</code> : heap영역의 메모리 해제 가능</p></li> <li><p><code>mmap</code> : 파일, 메모리, 프로세스가 있다고 생각하자. 프로세스에서 파일을 접근하는건 시간이 굉장히 많이 걸린다. mmap은 파일을 메모리에 매핑하여 미리 올려놓을수 있다. 이러면 시스템콜, 스케쥴러, 인터럽트, dma, 시스템버스 모두 필요 없어서 굉장히 빨라진다.</p></li> <li><p>![image-20210509203304038](./System Programming.assets/image-20210509203304038.png)</p></li> <li><p>파일 액세스를 줄여서 성능을 높인다. 가상 메모리와 흡사한 메커니즘이다.</p></li> <li><p>장점</p> <ul><li>read, write의 반복적 파일 접근 방지</li> <li>파일 처리를 위핸 lseek(느림)를쓰지 않고 포인터 조작으로 탐색 가능</li></ul></li> <li><p>단점</p> <ul><li>페이지 사이즈 단위로 매핑된다(4kb)
<ul><li>페이지 사이즈 단위가 정수배가 아니면 한 페이지 정도 낭비한다.</li></ul></li></ul></li> <li><p><code>int msync(void *start, size_t length, int flags)</code></p> <ul><li>start : mmap() 을 통해 받은 메모리 맵의 주소</li> <li>length : 동기화 할 길이</li> <li>flags : 비동기, 동기 방식을 정한다. 동기시 블럭 상태로 대기 한다.</li></ul></li> <li><p><code>int munmap(void *addr)</code></p></li></ul> <h3 id="stat"><a href="#stat" class="header-anchor">#</a> stat</h3> <blockquote><p>inode 정보를 받아온다.</p></blockquote> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">stat</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">stat</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">fstat</span><span class="token punctuation">(</span><span class="token keyword">int</span> filedes<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">stat</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li>stat : 스테이트</li> <li>const : 패스정보</li> <li>struct : 스테이트라는 구조체. inode자료구조를 가져온다.</li> <li>int : file 디스크립터를 넣는다.</li></ul> <p>![image-20210513023758209](./System Programming.assets/image-20210513023758209.png)</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/wiki/os/" class="prev">
        Operating System
      </a></span> <span class="next"><a href="/wiki/algorithm/">
        Algorithm
      </a>
      →
    </span></p></div>  <div class="back"><a href="/wiki" class="back-span">Back to list</a></div> <div class="theme-default-content"><!----></div></main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.8582b750.js" defer></script><script src="/assets/js/13.ac00c42d.js" defer></script><script src="/assets/js/1.31b6dd3f.js" defer></script><script src="/assets/js/47.bec85125.js" defer></script>
  </body>
</html>
